/// <reference types="node" />
import { EventEmitter } from 'events';
import { QueryManager } from '0g/dist-esm/QueryManager';
import { ComponentType } from '0g/dist-esm/Component';
import { ComponentManager } from '0g/dist-esm/ComponentManager';
import { IdManager } from '0g/dist-esm/IdManager';
import { ArchetypeManager } from '0g/dist-esm/ArchetypeManager';
import { Operation } from '0g/dist-esm/operations';
import { Entity } from '0g/dist-esm/Entity';
import { Resources } from '0g/dist-esm/Resources';
import { ObjectPool } from '0g/dist-esm/internal/objectPool';
import { AssetLoaders, Globals } from '0g';
import { Assets } from '0g/dist-esm/Assets';
import { QueryComponentFilter } from '0g/dist-esm/Query';
import { EntityImpostorFor } from '0g/dist-esm/QueryIterator';
export declare type GameConstants = {
    maxComponentId: number;
    maxEntities: number;
};
export interface GameEvents {
    preStep(): any;
    step(): any;
    postStep(): any;
    stepComplete(): any;
    preApplyOperations(): any;
    destroyEntities(): any;
}
export declare interface Game {
    on<U extends keyof GameEvents>(event: U, callback: GameEvents[U]): this;
    off<U extends keyof GameEvents>(event: U, callback: GameEvents[U]): this;
    emit<U extends keyof GameEvents>(event: U, ...args: Parameters<GameEvents[U]>): boolean;
}
export declare class Game extends EventEmitter {
    private _queryManager;
    private _idManager;
    private _archetypeManager;
    private _operationQueue;
    private _componentManager;
    private _globals;
    private _runnableCleanups;
    private _entityPool;
    private _removedList;
    private _assets;
    private _phases;
    private _delta;
    private _time;
    private _constants;
    constructor({ components, systems, assetLoaders, }: {
        components: ComponentType<any>[];
        systems?: ((game: Game) => () => void)[];
        assetLoaders?: AssetLoaders;
    });
    get idManager(): IdManager;
    get componentManager(): ComponentManager;
    get archetypeManager(): ArchetypeManager;
    get delta(): number;
    get time(): number;
    get queryManager(): QueryManager;
    get constants(): GameConstants;
    get globals(): Resources<Globals>;
    get assets(): Assets<AssetLoaders>;
    get entityPool(): ObjectPool<Entity<ComponentType<any>, any>>;
    /**
     * Allocates a new entity id and enqueues an operation to create the entity at the next opportunity.
     */
    create: () => number;
    /**
     * Enqueues an entity to be destroyed at the next opportunity
     */
    destroy: (id: number) => void;
    /**
     * Add a component to an entity.
     */
    add: <ComponentShape>(entityId: number, Type: ComponentType<ComponentShape>, initial?: Partial<ComponentShape> | undefined) => void;
    /**
     * Remove a component by type from an entity
     */
    remove: <T extends ComponentType<any>>(entityId: number, Type: T) => void;
    /**
     * Get a single entity by its known ID
     */
    get: (entityId: number) => Entity<any> | null;
    /**
     * Run some logic for each entity that meets an ad-hoc query.
     */
    query: <Filter extends QueryComponentFilter>(filter: Filter, run: (entity: EntityImpostorFor<Filter>, game: this) => void) => void;
    /**
     * Manually step the game simulation forward. Provide a
     * delta (in ms) of time elapsed since last frame.
     */
    step: (delta: number) => void;
    enqueueOperation: (operation: Operation) => void;
    private destroyEntity;
    private flushOperations;
    private applyOperation;
}
